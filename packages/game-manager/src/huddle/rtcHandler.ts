import { WebhookReceiver } from "@huddle01/server-sdk/webhooks";
import type { GameMessage, MessageType, Room } from "../types/game.js";
import type { RTCMessage } from "../types/rtc.js";
import { GameManager } from "../game/gameManager.js";
import db from "../db/index.js";

const API_KEY = process.env.HUDDLE01_API_KEY;
if (!API_KEY) throw new Error("HUDDLE01_API_KEY is not set");

const webhookReceiver = new WebhookReceiver({
  apiKey: API_KEY,
});

// Message validators for different message types
const messageValidators: Record<MessageType, (message: GameMessage, gameManager: GameManager) => Promise<boolean>> = {
  chat: async (message, gameManager) => {
    return gameManager.validateChatMessage(message.sender);
  },
  vote: async (message, gameManager) => {
    if (!message.metadata?.target) return false;
    return gameManager.validateVote(message.sender, message.metadata.target);
  },
  // System messages are only generated by the server
  system: async () => false,
  ai_action: async () => false,
  death: async () => false,
  phase_change: async () => false,
  ready: async (message, gameManager) => {
    if (message.metadata?.ready === undefined) return false;
    return gameManager.validateReadyStatus(message.sender);
  },
  game_start: async () => false,
};

export async function handleRTCMessage(signature: string, body: string) {
  try {
    // Verify webhook signature
    let isValid = webhookReceiver.verifySignature(signature, body);
    if (!isValid) {
      console.error("Invalid webhook signature");
      return false;
    }

    const data = JSON.parse(body) as RTCMessage;
    const { roomId } = data;
    if (!roomId) return false;

    // Get room and create game manager
    const room = (await new Promise((resolve, reject) => {
      roomsDb.findOne({ roomId }, (err, doc) => {
        if (err) reject(err);
        else resolve(doc);
      });
    })) as Room | null;

    if (!room) return false;

    const gameManager = new GameManager(roomId, room.gameState, room.settings);

    // Validate message based on type
    const validator = messageValidators[data.data.type];
    if (!validator) return false;

    isValid = await validator(data.data, gameManager);
    if (!isValid) return false;

    // Update database with the new message
    await new Promise<void>((resolve, reject) => {
      roomsDb.update({ roomId }, { $push: { messages: data.data } }, {}, err => {
        if (err) reject(err);
        else resolve();
      });
    });

    // Process game actions based on message type
    switch (data.data.type) {
      case "vote":
        if (data.data.metadata?.target) {
          await gameManager.handleVote(data.data.sender, data.data.metadata.target);
        }
        break;
      case "ready":
        if (data.data.metadata?.ready !== undefined) {
          await gameManager.handleReadyStatus(data.data.sender, data.data.metadata.ready);
        }
        break;
    }

    return true;
  } catch (error) {
    console.error("Error handling RTC message:", error);
    return false;
  }
}
