import { roomsDb } from "../db/index.js";
import { GameManager } from "../game/gameManager.js";
import type { GameMessage, MessageType, RTCMessage } from "@mafia/types/rtc";
import type { GameRoom } from "@mafia/types/api";

// Message validators for different message types
const messageValidators: Record<MessageType, (message: GameMessage, gameManager: GameManager) => Promise<boolean>> = {
  chat: async (message, gameManager) => {
    return gameManager.validateChatMessage(message.playerId);
  },
  vote: async (message, gameManager) => {
    if (message.type !== "vote") return false;
    return gameManager.validateVote(message.playerId, message.payload.vote);
  },
  // System messages are only generated by the server
  system: async () => true,

  death: async () => true,
  phase_change: async () => true,
  game_start: async () => true,

  ready: async () => true,
};

export async function handleRTCMessage(message: RTCMessage): Promise<boolean> {
  try {
    const { roomId } = message;
    if (!roomId) return false;

    // Get room and create game manager
    const room = (await new Promise((resolve, reject) => {
      roomsDb.findOne({ roomId }, (err, doc) => {
        if (err) reject(err);
        else resolve(doc);
      });
    })) as GameRoom | null;

    if (!room) return false;

    const gameManager = new GameManager(roomId, room.gameState, room.settings);

    // Validate message based on type
    const validator = messageValidators[message.data.type as MessageType];
    if (!validator) return false;

    const isValid = await validator(message.data, gameManager);
    if (!isValid) return false;

    // Update database with the new message
    await new Promise<void>((resolve, reject) => {
      roomsDb.update({ roomId }, { $push: { messages: message.data } }, {}, err => {
        if (err) reject(err);
        else resolve();
      });
    });

    // Process game actions based on message type
    switch (message.data.type) {
      case "vote":
        await gameManager.handleVote(message.data.playerId, message.data.payload.vote);
        break;
    }

    return true;
  } catch (error) {
    console.error("Error handling RTC message:", error);
    return false;
  }
}
