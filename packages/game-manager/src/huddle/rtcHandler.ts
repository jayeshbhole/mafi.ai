import { WebhookReceiver } from "@huddle01/server-sdk/webhooks";
import { roomsDb } from "../db/index.js";
import { GameManager } from "../game/gameManager.js";
import type { GameMessage, RTCMessage } from "@mafia/types/rtc";
import type { GameRoom } from "@mafia/types/api";
import type { MessageType } from "@mafia/types/game";

const API_KEY = process.env.HUDDLE01_API_KEY;
if (!API_KEY) throw new Error("HUDDLE01_API_KEY is not set");

const webhookReceiver = new WebhookReceiver({
  apiKey: API_KEY,
});

// Message validators for different message types
const messageValidators: Record<MessageType, (message: GameMessage, gameManager: GameManager) => Promise<boolean>> = {
  chat: async (message, gameManager) => {
    return gameManager.validateChatMessage(message.payload.playerId);
  },
  vote: async (message, gameManager) => {
    if (message.type !== "vote") return false;
    return gameManager.validateVote(message.payload.playerId, message.payload.playerName);
  },
  // System messages are only generated by the server
  system: async () => true,
  ai_action: async () => true,
  death: async () => true,
  phase_change: async () => true,
  game_start: async () => true,
  "system-alert": async () => true,
  "system-success": async () => true,
  ready: async () => true,
};

export async function handleRTCMessage(signature: string, body: string) {
  try {
    // Verify webhook signature
    let isValid = webhookReceiver.verifySignature(signature, body);
    if (!isValid) {
      console.error("Invalid webhook signature");
      return false;
    }

    const data = JSON.parse(body) as RTCMessage;
    const { roomId } = data;
    if (!roomId) return false;

    // Get room and create game manager
    const room = (await new Promise((resolve, reject) => {
      roomsDb.findOne({ roomId }, (err, doc) => {
        if (err) reject(err);
        else resolve(doc);
      });
    })) as GameRoom | null;

    if (!room) return false;

    const gameManager = new GameManager(roomId, room.gameState, room.settings);

    // Validate message based on type
    const validator = messageValidators[data.data.type as MessageType];
    if (!validator) return false;

    isValid = await validator(data.data, gameManager);
    if (!isValid) return false;

    // Update database with the new message
    await new Promise<void>((resolve, reject) => {
      roomsDb.update({ roomId }, { $push: { messages: data.data } }, {}, err => {
        if (err) reject(err);
        else resolve();
      });
    });

    // Process game actions based on message type
    switch (data.data.type) {
      case "vote":
        await gameManager.handleVote(data.data.payload.playerId, data.data.payload.playerName);
        break;
    }

    return true;
  } catch (error) {
    console.error("Error handling RTC message:", error);
    return false;
  }
}
